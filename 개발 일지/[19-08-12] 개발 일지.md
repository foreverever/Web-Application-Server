### 오늘 개발 목표
* RequestHandler 클래스의 책임을 분리

### 작업 내용
* 클라이언트 요청 데이터를 처리하는 로직을 별도의 클래스로 분리 (HttpRequest)

### 향후 작업 내용
* Controller를 통한 요청 처리

### 느낀점

* **김태수**

    > 특정 헤더 값을 가져올 때 BufferedReader.ReadLine()을 통해 값을 찾을지, 최초 요청 시 모든 헤더의 값을
    Map에 저장하여 찾을지에 대한 논쟁이 있었다. 만약 특정 요청에서 하나의 헤더값만 필요할 경우 ReadLine()을 통해서
    헤더값을 찾는 것이 더 나은 방법이라고 생각했다. Map을 사용하게 될 경우, 사용 안하는 헤더값까지 저장을 해야하기 때문에
    공간복잡도가 높아진다고 생각했기 때문이다. 하지만, 만약 특정 요청에서 다양한 헤더값을 사용하게 될 경우에는 Map에 저장한
    값을 바로 가져와 사용할 수 있기 때문에 시간복잡도 측면에서 더 유리하다. 따라서 Map을 통해 헤더값을 찾도록 구현했다.
    기능 구현에는 정답이 없다. 따라서 성능 측면이나, 추후 발생할 수 있는 문제를 예방하도록 코드 품질에 대한 많은 고민이
    필요하다는 것을 느꼈다. 이러한 부분들을 팀원들과 함께 고민하고 토론하는 것이 뜻 깊었던 하루였다.


* **김성렬**

    > 클라이언트가 보낸 요청 Http request 메시지를 Map의 키 밸류로 받을지, 아니면 응답 메시지에 필요한 요청 메시지만 지역변수로 읽어 올지 논의 했습니다.
    논의 끝에 Map으로 받아 헤더 정보가 다수 필요할 경우 map에서 꺼내오는 것이 좋을 거 같다는 결론을 내리게 되었습니다.
    또한 테스트 메서드를 만드는 과정에서 요청 헤더와 메시지 사이 Blank Line에 " "으로 알고 있었는데 \n 으로 이루어져 있다는 것을 알게 되었습니다.
    그래서 BufferedReader가 \n를 기준으로 읽어와서 EOF를 식별 함을 다시 한번 알게되는 계기 였습니다.
    요청에 대해서 GET 과 POST 방식을 나누고 요청 url은 어떻게 처리해야 할지 설계에 대해 고민을 했습니다.


* **성건희**
   
    > 현재 RequestHandler 클래스의 run 메서드는 너무 방대한 일을 처리하고 있습니다.
    > 따라서 요청과 응답에 대한 처리를 별도의 클래스를 통해 관리하기로 결정하였고,
    > 현재는 요청에 대한 처리만 개발하였습니다. 요청에 관한 처리를 HttpRequest 클래스로 분리하였고
    > 인스턴스 변수로 RequestLine, headers를 가지게 하였습니다. 요청에 대한 처리를 한곳으로 모은 것은 좋았지만, HttpRequest 클래스를 만들때 내부에서 객체를 만들지 않고, 생성자로 RequestLine, Header, Body의 객체들을 주입하는 방식이 더 유지보수하기 좋지 않을까 생각됩니다. 해당 부분은 좀 더 고민해볼 예정입니다.
    >
    > <의견 충돌>
    > 개발도중 Request Header를 Map에 담아서 관리하는 것이 나을지, 기존 방식처럼 while로 원하는 헤더를 읽어들이는것이 나을지에 대한 의견 충돌이 있었습니다. 저의 경우, 지금은 회원가입 처리에 Content-Length 헤더값만 사용하고 있지만 요구사항이 늘어나면 다양한 헤더값을 사용하는 경우가 생길 수 있어 Map에 담아서 관리하는 것이 더 나을것 같다는 의견이었고, 다른 팀원은 필요한 부분에 대한 처리만 while을 통해서 가져오면 되지 불필요하게 사용하지 않는 헤더값을 Map에 담아 공간복잡도를 높일 필요가 있느냐의 의견으로 갈렸습니다.
    >
    > 팀원간의 토의끝에 헤더값을 Map에 담아 공간복잡도가 크게 성능상의 이슈를 불러일으키지는 않을 것이라는 결론이 나왔고, 오히려 Map을 사용하여 중복과 if문을 제거하는 효과를 기대할 수 있어 Map을 사용하기로 결정하였습니다.
